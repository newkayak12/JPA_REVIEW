 JPQL의 조회 대상은 에티티, 임베디드 타입, 값 타입이다.
 영속성 컨텍스트의 관리 대상은 엔티티 하나이다 . 따라서 임베디드 타입을 조회하고 값을 변경해도 영속성 컨텍스트는 이에 반응하지 않는다.
 그러나 엔티티를 통째로 부르고 값을 수정하면 임베디드 타입이 수정된다.
 정리하면 조회한 엔티티만 영속성 컨텍스트가 관리한다는 것이다.


 JPQL로 조회한 엔티티와 영속성 컨텍스트

   JPQL로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 있으면 JPQL로 DB에서 조회한 결과를 버리고 대신, 영속성 컨텍스트에 있던 엔티티를 반환한다. 이 떄 비교 대상은 식별자 값이다.
 예를 들어 member1이 영속성 컨텍스트에 있다고 하자. JPQL로 member1,2를 조회하면 DB에서 조회한 member1은 버리고 member2를 가지고 와서 영속성 컨텍스트에 추가한다.
 마지막으로 영속성 컨텍스트에 있는 member1,2를 반환한다.

 왜? 이를 버리는 것일까? 새로 교체하면 안되는 것일까?
 이는 영속성 컨텍스트에 있던 엔티티에 수정이 벌어지고 있는 경우라면 수정 중인 데이터가 사라질 수 있다는 단점이 있기 때문에 이전에 있던 것을 가지고 있고 새로 추출한 것을 버리는 것으로 보인다.
 즉, 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장하는 것에 우선순위를 둔다.



 find() vs JPQL
 em.find()는 엔티티를 먼저 영속성 컨텍스트에서 찾고 없으면 DB에서 찾는다. (1차 캐시라고 부른다.)

 JPQL은 어떻게 동작할까? JPQL은 항상 DB에서 SQL을 실행하서 결과를 조회한다. 그 후 영속성 컨텍스트에 들렀다 온다.
    > JPQL은 항상 DB를 조회한다.
    > JPQL로 조회한 엔티티는 영속 상태이다.
    > 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.




 JPQL과 플러시 모드
    flush는 영속성 컨텍스트의 변경 내역을 DB에 동기화하는 것이다. JPA는 플러시가 일어날 때 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서 INSERT, UPDATE, DELETE 등의 SQL문을 만들어 DB에 반영한다.
    플러시를 호출하려면 em.flush()를 걸어도 좋지만
    em.setFlushMode(FlushModeType.AUTO) // commit 또는 쿼리 실행시(기본값)
    em.setFlushMode(FlushModeType.COMMIT) // 커밋 시에만 플러시
    로 플러시를 할 수 있다. (이 옵션을 성능 최적화를 위해 꼭 필요할 때만 사용하는 것이 좋다.)


JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 DB에서 먼저 데이터를 조죄한다. 따라서, JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 DB에 반영해야한다. 그렇지 ㅇ낳으면 의도하지 않은 결과가 발생할 수 있다.
